"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
const net_1 = __importDefault(require("net"));
const events_1 = __importDefault(require("events"));
const utils_1 = require("./utils");
class Server extends events_1.default.EventEmitter {
    constructor(host, 
    /* TODO: allowing port to be string or undefined is used by the tests, but seems bad overall. */
    port, username, password, options) {
        super();
        this.responseBuffer = Buffer.from([]);
        this.host = host;
        this.port = port;
        this.connected = false;
        this.timeoutSet = false;
        this.connectCallbacks = [];
        this.responseCallbacks = {};
        this.requestTimeouts = [];
        this.errorCallbacks = {};
        this.options = utils_1.merge(options || {}, {
            timeout: 0.5,
            keepAlive: false,
            keepAliveDelay: 30,
        });
        if (this.options.conntimeout === undefined ||
            this.options.conntimeout === null) {
            this.options.conntimeout = 2 * this.options.timeout;
        }
        this.username =
            username ||
                this.options.username ||
                process.env.MEMCACHIER_USERNAME ||
                process.env.MEMCACHE_USERNAME;
        this.password =
            password ||
                this.options.password ||
                process.env.MEMCACHIER_PASSWORD ||
                process.env.MEMCACHE_PASSWORD;
        return this;
    }
    onConnect(func) {
        this.connectCallbacks.push(func);
    }
    onResponse(seq, func) {
        this.responseCallbacks[seq] = func;
    }
    respond(response) {
        const callback = this.responseCallbacks[response.header.opaque];
        if (!callback) {
            // in case of authentication, no callback is registered
            return;
        }
        callback(response);
        if (!callback.quiet || response.header.totalBodyLength === 0) {
            delete this.responseCallbacks[response.header.opaque];
            this.requestTimeouts.shift();
            delete this.errorCallbacks[response.header.opaque];
        }
    }
    onError(seq, func) {
        this.errorCallbacks[seq] = func;
    }
    error(err) {
        const errcalls = this.errorCallbacks;
        this.connectCallbacks = [];
        this.responseCallbacks = {};
        this.requestTimeouts = [];
        this.errorCallbacks = {};
        this.timeoutSet = false;
        if (this._socket) {
            this._socket.destroy();
            delete this._socket;
        }
        for (let errcall of Object.values(errcalls)) {
            errcall(err);
        }
    }
    listSasl() {
        const buf = utils_1.makeRequestBuffer(0x20, "", "", "");
        this.writeSASL(buf);
    }
    saslAuth() {
        const authStr = "\x00" + this.username + "\x00" + this.password;
        const buf = utils_1.makeRequestBuffer(0x21, "PLAIN", "", authStr);
        this.writeSASL(buf);
    }
    appendToBuffer(dataBuf) {
        const old = this.responseBuffer;
        this.responseBuffer = Buffer.alloc(old.length + dataBuf.length);
        old.copy(this.responseBuffer, 0);
        dataBuf.copy(this.responseBuffer, old.length);
        return this.responseBuffer;
    }
    responseHandler(dataBuf) {
        let response;
        try {
            response = utils_1.parseMessage(this.appendToBuffer(dataBuf));
        }
        catch (e) {
            this.error(e);
            return;
        }
        let respLength;
        while (response) {
            if (response.header.opcode === 0x20) {
                this.saslAuth();
            }
            else if (response.header.status === 0x20 /* TODO: wtf? */) {
                this.error(new Error("Memcached server authentication failed!"));
            }
            else if (response.header.opcode === 0x21) {
                this.emit("authenticated");
            }
            else {
                this.respond(response);
            }
            respLength = response.header.totalBodyLength + 24;
            this.responseBuffer = this.responseBuffer.slice(respLength);
            response = utils_1.parseMessage(this.responseBuffer);
        }
    }
    sock(sasl, go) {
        const self = this;
        if (!self._socket) {
            // CASE 1: completely new socket
            self.connected = false;
            self._socket = net_1.default.connect(
            /* TODO: allowing port to be string or undefined is used by the tests, but seems bad overall. */
            typeof this.port === "string"
                ? parseInt(this.port, 10)
                : this.port || 11211, this.host, function () {
                // SASL authentication handler
                self.once("authenticated", function () {
                    if (self._socket) {
                        const socket = self._socket;
                        self.connected = true;
                        // cancel connection timeout
                        self._socket.setTimeout(0);
                        self.timeoutSet = false;
                        // run actual request(s)
                        go(self._socket);
                        self.connectCallbacks.forEach(function (cb) {
                            cb(socket);
                        });
                        self.connectCallbacks = [];
                    }
                });
                // setup response handler
                this.on("data", function (dataBuf) {
                    self.responseHandler(dataBuf);
                });
                // kick of SASL if needed
                if (self.username && self.password) {
                    self.listSasl();
                }
                else {
                    self.emit("authenticated");
                }
            });
            // setup error handler
            self._socket.on("error", function (error) {
                self.error(error);
            });
            self._socket.on("close", function () {
                var _a;
                if (Object.keys(self.errorCallbacks).length > 0) {
                    self.error(new Error("socket closed unexpectedly."));
                }
                self.connected = false;
                if (self.timeoutSet) {
                    (_a = self._socket) === null || _a === void 0 ? void 0 : _a.setTimeout(0);
                    self.timeoutSet = false;
                }
                self._socket = undefined;
            });
            // setup connection timeout handler
            self.timeoutSet = true;
            self._socket.setTimeout(self.options.conntimeout * 1000, function () {
                self.timeoutSet = false;
                if (!self.connected) {
                    this.end();
                    self._socket = undefined;
                    self.error(new Error("socket timed out connecting to server."));
                }
            });
            // use TCP keep-alive
            self._socket.setKeepAlive(self.options.keepAlive, self.options.keepAliveDelay * 1000);
        }
        else if (!self.connected && !sasl) {
            // CASE 2: socket exists, but still connecting / authenticating
            self.onConnect(go);
        }
        else {
            // CASE 3: socket exists and connected / ready to use
            go(self._socket);
        }
    }
    write(blob) {
        const self = this;
        const deadline = Math.round(self.options.timeout * 1000);
        this.sock(false, function (s) {
            s.write(blob);
            self.requestTimeouts.push(utils_1.timestamp() + deadline);
            if (!self.timeoutSet) {
                self.timeoutSet = true;
                s.setTimeout(deadline, function () {
                    timeoutHandler(self, this);
                });
            }
        });
    }
    writeSASL(blob) {
        this.sock(true, function (s) {
            s.write(blob);
        });
    }
    close() {
        if (this._socket) {
            this._socket.end();
        }
    }
    toString() {
        return "<Server " + this.host + ":" + this.port + ">";
    }
    hostportString() {
        return this.host + ":" + this.port;
    }
}
exports.Server = Server;
// We handle tracking timeouts with an array of deadlines (requestTimeouts), as
// node doesn't like us setting up lots of timers, and using just one is more
// efficient anyway.
const timeoutHandler = function (server, sock) {
    if (server.requestTimeouts.length === 0) {
        // nothing active
        server.timeoutSet = false;
        return;
    }
    // some requests outstanding, check if any have timed-out
    const now = utils_1.timestamp();
    const soonestTimeout = server.requestTimeouts[0];
    if (soonestTimeout <= now) {
        // timeout occurred!
        sock.end();
        server.connected = false;
        server._socket = undefined;
        server.timeoutSet = false;
        server.error(new Error("socket timed out waiting on response."));
    }
    else {
        // no timeout! Setup next one.
        const deadline = soonestTimeout - now;
        sock.setTimeout(deadline, function () {
            timeoutHandler(server, sock);
        });
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL21lbWpzL3NlcnZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw4Q0FBc0I7QUFDdEIsb0RBQTRCO0FBQzVCLG1DQU1pQjtBQTBCakIsTUFBYSxNQUFPLFNBQVEsZ0JBQU0sQ0FBQyxZQUFZO0lBZ0I3QyxZQUNFLElBQVk7SUFDWixnR0FBZ0c7SUFDaEcsSUFBc0IsRUFDdEIsUUFBaUIsRUFDakIsUUFBaUIsRUFDakIsT0FBZ0M7UUFFaEMsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsRUFBRSxDQUFDO1FBQzVCLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBSyxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUU7WUFDbEMsT0FBTyxFQUFFLEdBQUc7WUFDWixTQUFTLEVBQUUsS0FBSztZQUNoQixjQUFjLEVBQUUsRUFBRTtTQUNuQixDQUFrQixDQUFDO1FBQ3BCLElBQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEtBQUssU0FBUztZQUN0QyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsS0FBSyxJQUFJLEVBQ2pDO1lBQ0EsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFX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LElBQUksQ0FBQztJQUNyQyxDQUFDO0NBQ0Y7QUExUUQsd0JBMFFDO0FBRUQsK0VBQStFO0FBQy9FLDZFQUE2RTtBQUM3RSxvQkFBb0I7QUFDcEIsTUFBTSxjQUFjLEdBQUcsVUFBVSxNQUFjLEVBQUUsSUFBZ0I7SUFDL0QsSUFBSSxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDdkMsaUJBQWlCO1FBQ2pCLE1BQU0sQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQzFCLE9BQU87S0FDUjtJQUVELHlEQUF5RDtJQUN6RCxNQUFNLEdBQUcsR0FBRyxpQkFBUyxFQUFFLENBQUM7SUFDeEIsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVqRCxJQUFJLGNBQWMsSUFBSSxHQUFHLEVBQUU7UUFDekIsb0JBQW9CO1FBQ3BCLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNYLE1BQU0sQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLE1BQU0sQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQzFCLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsdUNBQXVDLENBQUMsQ0FBQyxDQUFDO0tBQ2xFO1NBQU07UUFDTCw4QkFBOEI7UUFDOUIsTUFBTSxRQUFRLEdBQUcsY0FBYyxHQUFHLEdBQUcsQ0FBQztRQUN0QyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRTtZQUN4QixjQUFjLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9CLENBQUMsQ0FBQyxDQUFDO0tBQ0o7QUFDSCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmV0IGZyb20gXCJuZXRcIjtcbmltcG9ydCBldmVudHMgZnJvbSBcImV2ZW50c1wiO1xuaW1wb3J0IHtcbiAgbWFrZVJlcXVlc3RCdWZmZXIsXG4gIHBhcnNlTWVzc2FnZSxcbiAgbWVyZ2UsXG4gIHRpbWVzdGFtcCxcbiAgTWVzc2FnZSxcbn0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBTZXJ2ZXJPcHRpb25zIHtcbiAgdGltZW91dDogbnVtYmVyO1xuICBrZWVwQWxpdmU6IGJvb2xlYW47XG4gIGtlZXBBbGl2ZURlbGF5OiBudW1iZXI7XG4gIGNvbm50aW1lb3V0OiBudW1iZXI7XG4gIHVzZXJuYW1lPzogc3RyaW5nO1xuICBwYXNzd29yZD86IHN0cmluZztcbn1cblxudHlwZSBTZXEgPSBudW1iZXI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT25Db25uZWN0Q2FsbGJhY2sge1xuICAoc29ja2V0OiBuZXQuU29ja2V0KTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPblJlc3BvbnNlQ2FsbGJhY2sge1xuICAobWVzc2FnZTogTWVzc2FnZSk6IHZvaWQ7XG4gIHF1aWV0PzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPbkVycm9yQ2FsbGJhY2sge1xuICAoZXJyb3I6IEVycm9yKTogdm9pZDtcbn1cblxuZXhwb3J0IGNsYXNzIFNlcnZlciBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXIge1xuICByZXNwb25zZUJ1ZmZlcjogQnVmZmVyO1xuICBob3N0OiBzdHJpbmc7XG4gIHBvcnQ6IHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgY29ubmVjdGVkOiBib29sZWFuO1xuICB0aW1lb3V0U2V0OiBib29sZWFuO1xuICBjb25uZWN0Q2FsbGJhY2tzOiBPbkNvbm5lY3RDYWxsYmFja1tdO1xuICByZXNwb25zZUNhbGxiYWNrczogeyBbc2VxOiBzdHJpbmddOiBPblJlc3BvbnNlQ2FsbGJhY2sgfTtcbiAgcmVxdWVzdFRpbWVvdXRzOiBudW1iZXJbXTtcbiAgZXJyb3JDYWxsYmFja3M6IHsgW3NlcTogc3RyaW5nXTogT25FcnJvckNhbGxiYWNrIH07XG4gIG9wdGlvbnM6IFNlcnZlck9wdGlvbnM7XG4gIHVzZXJuYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHBhc3N3b3JkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgX3NvY2tldDogbmV0LlNvY2tldCB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBob3N0OiBzdHJpbmcsXG4gICAgLyogVE9ETzogYWxsb3dpbmcgcG9ydCB0byBiZSBzdHJpbmcgb3IgdW5kZWZpbmVkIGlzIHVzZWQgYnkgdGhlIHRlc3RzLCBidXQgc2VlbXMgYmFkIG92ZXJhbGwuICovXG4gICAgcG9ydD86IHN0cmluZyB8IG51bWJlcixcbiAgICB1c2VybmFtZT86IHN0cmluZyxcbiAgICBwYXNzd29yZD86IHN0cmluZyxcbiAgICBvcHRpb25zPzogUGFydGlhbDxTZXJ2ZXJPcHRpb25zPlxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucmVzcG9uc2VCdWZmZXIgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICB0aGlzLnBvcnQgPSBwb3J0O1xuICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgdGhpcy5jb25uZWN0Q2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMucmVxdWVzdFRpbWVvdXRzID0gW107XG4gICAgdGhpcy5lcnJvckNhbGxiYWNrcyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIHRpbWVvdXQ6IDAuNSxcbiAgICAgIGtlZXBBbGl2ZTogZmFsc2UsXG4gICAgICBrZWVwQWxpdmVEZWxheTogMzAsXG4gICAgfSkgYXMgU2VydmVyT3B0aW9ucztcbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMuY29ubnRpbWVvdXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5vcHRpb25zLmNvbm50aW1lb3V0ID09PSBudWxsXG4gICAgKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuY29ubnRpbWVvdXQgPSAyICogdGhpcy5vcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMudXNlcm5hbWUgPVxuICAgICAgdXNlcm5hbWUgfHxcbiAgICAgIHRoaXMub3B0aW9ucy51c2VybmFtZSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuTUVNQ0FDSElFUl9VU0VSTkFNRSB8fFxuICAgICAgcHJvY2Vzcy5lbnYuTUVNQ0FDSEVfVVNFUk5BTUU7XG4gICAgdGhpcy5wYXNzd29yZCA9XG4gICAgICBwYXNzd29yZCB8fFxuICAgICAgdGhpcy5vcHRpb25zLnBhc3N3b3JkIHx8XG4gICAgICBwcm9jZXNzLmVudi5NRU1DQUNISUVSX1BBU1NXT1JEIHx8XG4gICAgICBwcm9jZXNzLmVudi5NRU1DQUNIRV9QQVNTV09SRDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9uQ29ubmVjdChmdW5jOiBPbkNvbm5lY3RDYWxsYmFjaykge1xuICAgIHRoaXMuY29ubmVjdENhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICB9XG5cbiAgb25SZXNwb25zZShzZXE6IFNlcSwgZnVuYzogT25SZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tzZXFdID0gZnVuYztcbiAgfVxuXG4gIHJlc3BvbmQocmVzcG9uc2U6IE1lc3NhZ2UpIHtcbiAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMucmVzcG9uc2VDYWxsYmFja3NbcmVzcG9uc2UuaGVhZGVyLm9wYXF1ZV07XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgLy8gaW4gY2FzZSBvZiBhdXRoZW50aWNhdGlvbiwgbm8gY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgaWYgKCFjYWxsYmFjay5xdWlldCB8fCByZXNwb25zZS5oZWFkZXIudG90YWxCb2R5TGVuZ3RoID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tyZXNwb25zZS5oZWFkZXIub3BhcXVlXTtcbiAgICAgIHRoaXMucmVxdWVzdFRpbWVvdXRzLnNoaWZ0KCk7XG4gICAgICBkZWxldGUgdGhpcy5lcnJvckNhbGxiYWNrc1tyZXNwb25zZS5oZWFkZXIub3BhcXVlXTtcbiAgICB9XG4gIH1cblxuICBvbkVycm9yKHNlcTogU2VxLCBmdW5jOiBPbkVycm9yQ2FsbGJhY2spIHtcbiAgICB0aGlzLmVycm9yQ2FsbGJhY2tzW3NlcV0gPSBmdW5jO1xuICB9XG5cbiAgZXJyb3IoZXJyOiBFcnJvcikge1xuICAgIGNvbnN0IGVycmNhbGxzID0gdGhpcy5lcnJvckNhbGxiYWNrcztcbiAgICB0aGlzLmNvbm5lY3RDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy5yZXF1ZXN0VGltZW91dHMgPSBbXTtcbiAgICB0aGlzLmVycm9yQ2FsbGJhY2tzID0ge307XG4gICAgdGhpcy50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zb2NrZXQ7XG4gICAgfVxuICAgIGZvciAobGV0IGVycmNhbGwgb2YgT2JqZWN0LnZhbHVlcyhlcnJjYWxscykpIHtcbiAgICAgIGVycmNhbGwoZXJyKTtcbiAgICB9XG4gIH1cblxuICBsaXN0U2FzbCgpIHtcbiAgICBjb25zdCBidWYgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDIwLCBcIlwiLCBcIlwiLCBcIlwiKTtcbiAgICB0aGlzLndyaXRlU0FTTChidWYpO1xuICB9XG5cbiAgc2FzbEF1dGgoKSB7XG4gICAgY29uc3QgYXV0aFN0ciA9IFwiXFx4MDBcIiArIHRoaXMudXNlcm5hbWUgKyBcIlxceDAwXCIgKyB0aGlzLnBhc3N3b3JkO1xuICAgIGNvbnN0IGJ1ZiA9IG1ha2VSZXF1ZXN0QnVmZmVyKDB4MjEsIFwiUExBSU5cIiwgXCJcIiwgYXV0aFN0cik7XG4gICAgdGhpcy53cml0ZVNBU0woYnVmKTtcbiAgfVxuXG4gIGFwcGVuZFRvQnVmZmVyKGRhdGFCdWY6IEJ1ZmZlcikge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMucmVzcG9uc2VCdWZmZXI7XG4gICAgdGhpcy5yZXNwb25zZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvbGQubGVuZ3RoICsgZGF0YUJ1Zi5sZW5ndGgpO1xuICAgIG9sZC5jb3B5KHRoaXMucmVzcG9uc2VCdWZmZXIsIDApO1xuICAgIGRhdGFCdWYuY29weSh0aGlzLnJlc3BvbnNlQnVmZmVyLCBvbGQubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZUJ1ZmZlcjtcbiAgfVxuICByZXNwb25zZUhhbmRsZXIoZGF0YUJ1ZjogQnVmZmVyKSB7XG4gICAgbGV0IHJlc3BvbnNlOiBNZXNzYWdlIHwgZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3BvbnNlID0gcGFyc2VNZXNzYWdlKHRoaXMuYXBwZW5kVG9CdWZmZXIoZGF0YUJ1ZikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHJlc3BMZW5ndGg6IG51bWJlcjtcbiAgICB3aGlsZSAocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXIub3Bjb2RlID09PSAweDIwKSB7XG4gICAgICAgIHRoaXMuc2FzbEF1dGgoKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cyA9PT0gKDB4MjAgYXMgYW55KSAvKiBUT0RPOiB3dGY/ICovKSB7XG4gICAgICAgIHRoaXMuZXJyb3IobmV3IEVycm9yKFwiTWVtY2FjaGVkIHNlcnZlciBhdXRoZW50aWNhdGlvbiBmYWlsZWQhXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyLm9wY29kZSA9PT0gMHgyMSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNwb25kKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJlc3BMZW5ndGggPSByZXNwb25zZS5oZWFkZXIudG90YWxCb2R5TGVuZ3RoICsgMjQ7XG4gICAgICB0aGlzLnJlc3BvbnNlQnVmZmVyID0gdGhpcy5yZXNwb25zZUJ1ZmZlci5zbGljZShyZXNwTGVuZ3RoKTtcbiAgICAgIHJlc3BvbnNlID0gcGFyc2VNZXNzYWdlKHRoaXMucmVzcG9uc2VCdWZmZXIpO1xuICAgIH1cbiAgfVxuICBzb2NrKHNhc2w6IGJvb2xlYW4sIGdvOiBPbkNvbm5lY3RDYWxsYmFjaykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLl9zb2NrZXQpIHtcbiAgICAgIC8vIENBU0UgMTogY29tcGxldGVseSBuZXcgc29ja2V0XG4gICAgICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgc2VsZi5fc29ja2V0ID0gbmV0LmNvbm5lY3QoXG4gICAgICAgIC8qIFRPRE86IGFsbG93aW5nIHBvcnQgdG8gYmUgc3RyaW5nIG9yIHVuZGVmaW5lZCBpcyB1c2VkIGJ5IHRoZSB0ZXN0cywgYnV0IHNlZW1zIGJhZCBvdmVyYWxsLiAqL1xuICAgICAgICB0eXBlb2YgdGhpcy5wb3J0ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgPyBwYXJzZUludCh0aGlzLnBvcnQsIDEwKVxuICAgICAgICAgIDogdGhpcy5wb3J0IHx8IDExMjExLFxuICAgICAgICB0aGlzLmhvc3QsXG4gICAgICAgIGZ1bmN0aW9uICh0aGlzOiBuZXQuU29ja2V0KSB7XG4gICAgICAgICAgLy8gU0FTTCBhdXRoZW50aWNhdGlvbiBoYW5kbGVyXG4gICAgICAgICAgc2VsZi5vbmNlKFwiYXV0aGVudGljYXRlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fc29ja2V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHNlbGYuX3NvY2tldDtcbiAgICAgICAgICAgICAgc2VsZi5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBjYW5jZWwgY29ubmVjdGlvbiB0aW1lb3V0XG4gICAgICAgICAgICAgIHNlbGYuX3NvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgICAgICBzZWxmLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgLy8gcnVuIGFjdHVhbCByZXF1ZXN0KHMpXG4gICAgICAgICAgICAgIGdvKHNlbGYuX3NvY2tldCk7XG4gICAgICAgICAgICAgIHNlbGYuY29ubmVjdENhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGNiKHNvY2tldCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWxmLmNvbm5lY3RDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXJcbiAgICAgICAgICB0aGlzLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YUJ1Zikge1xuICAgICAgICAgICAgc2VsZi5yZXNwb25zZUhhbmRsZXIoZGF0YUJ1Zik7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBraWNrIG9mIFNBU0wgaWYgbmVlZGVkXG4gICAgICAgICAgaWYgKHNlbGYudXNlcm5hbWUgJiYgc2VsZi5wYXNzd29yZCkge1xuICAgICAgICAgICAgc2VsZi5saXN0U2FzbCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoXCJhdXRoZW50aWNhdGVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gc2V0dXAgZXJyb3IgaGFuZGxlclxuICAgICAgc2VsZi5fc29ja2V0Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHNlbGYuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG5cbiAgICAgIHNlbGYuX3NvY2tldC5vbihcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNlbGYuZXJyb3JDYWxsYmFja3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZWxmLmVycm9yKG5ldyBFcnJvcihcInNvY2tldCBjbG9zZWQgdW5leHBlY3RlZGx5LlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNlbGYudGltZW91dFNldCkge1xuICAgICAgICAgIHNlbGYuX3NvY2tldD8uc2V0VGltZW91dCgwKTtcbiAgICAgICAgICBzZWxmLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9zb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gc2V0dXAgY29ubmVjdGlvbiB0aW1lb3V0IGhhbmRsZXJcbiAgICAgIHNlbGYudGltZW91dFNldCA9IHRydWU7XG4gICAgICBzZWxmLl9zb2NrZXQuc2V0VGltZW91dChcbiAgICAgICAgc2VsZi5vcHRpb25zLmNvbm50aW1lb3V0ICogMTAwMCxcbiAgICAgICAgZnVuY3Rpb24gKHRoaXM6IG5ldC5Tb2NrZXQpIHtcbiAgICAgICAgICBzZWxmLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXNlbGYuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICAgICAgc2VsZi5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgc2VsZi5lcnJvcihuZXcgRXJyb3IoXCJzb2NrZXQgdGltZWQgb3V0IGNvbm5lY3RpbmcgdG8gc2VydmVyLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAvLyB1c2UgVENQIGtlZXAtYWxpdmVcbiAgICAgIHNlbGYuX3NvY2tldC5zZXRLZWVwQWxpdmUoXG4gICAgICAgIHNlbGYub3B0aW9ucy5rZWVwQWxpdmUsXG4gICAgICAgIHNlbGYub3B0aW9ucy5rZWVwQWxpdmVEZWxheSAqIDEwMDBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghc2VsZi5jb25uZWN0ZWQgJiYgIXNhc2wpIHtcbiAgICAgIC8vIENBU0UgMjogc29ja2V0IGV4aXN0cywgYnV0IHN0aWxsIGNvbm5lY3RpbmcgLyBhdXRoZW50aWNhdGluZ1xuICAgICAgc2VsZi5vbkNvbm5lY3QoZ28pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDQVNFIDM6IHNvY2tldCBleGlzdHMgYW5kIGNvbm5lY3RlZCAvIHJlYWR5IHRvIHVzZVxuICAgICAgZ28oc2VsZi5fc29ja2V0KTtcbiAgICB9XG4gIH1cblxuICB3cml0ZShibG9iOiBCdWZmZXIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBkZWFkbGluZSA9IE1hdGgucm91bmQoc2VsZi5vcHRpb25zLnRpbWVvdXQgKiAxMDAwKTtcbiAgICB0aGlzLnNvY2soZmFsc2UsIGZ1bmN0aW9uIChzKSB7XG4gICAgICBzLndyaXRlKGJsb2IpO1xuICAgICAgc2VsZi5yZXF1ZXN0VGltZW91dHMucHVzaCh0aW1lc3RhbXAoKSArIGRlYWRsaW5lKTtcbiAgICAgIGlmICghc2VsZi50aW1lb3V0U2V0KSB7XG4gICAgICAgIHNlbGYudGltZW91dFNldCA9IHRydWU7XG4gICAgICAgIHMuc2V0VGltZW91dChkZWFkbGluZSwgZnVuY3Rpb24gKHRoaXM6IG5ldC5Tb2NrZXQpIHtcbiAgICAgICAgICB0aW1lb3V0SGFuZGxlcihzZWxmLCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB3cml0ZVNBU0woYmxvYjogQnVmZmVyKSB7XG4gICAgdGhpcy5zb2NrKHRydWUsIGZ1bmN0aW9uIChzKSB7XG4gICAgICBzLndyaXRlKGJsb2IpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBcIjxTZXJ2ZXIgXCIgKyB0aGlzLmhvc3QgKyBcIjpcIiArIHRoaXMucG9ydCArIFwiPlwiO1xuICB9XG5cbiAgaG9zdHBvcnRTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9zdCArIFwiOlwiICsgdGhpcy5wb3J0O1xuICB9XG59XG5cbi8vIFdlIGhhbmRsZSB0cmFja2luZyB0aW1lb3V0cyB3aXRoIGFuIGFycmF5IG9mIGRlYWRsaW5lcyAocmVxdWVzdFRpbWVvdXRzKSwgYXNcbi8vIG5vZGUgZG9lc24ndCBsaWtlIHVzIHNldHRpbmcgdXAgbG90cyBvZiB0aW1lcnMsIGFuZCB1c2luZyBqdXN0IG9uZSBpcyBtb3JlXG4vLyBlZmZpY2llbnQgYW55d2F5LlxuY29uc3QgdGltZW91dEhhbmRsZXIgPSBmdW5jdGlvbiAoc2VydmVyOiBTZXJ2ZXIsIHNvY2s6IG5ldC5Tb2NrZXQpIHtcbiAgaWYgKHNlcnZlci5yZXF1ZXN0VGltZW91dHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gbm90aGluZyBhY3RpdmVcbiAgICBzZXJ2ZXIudGltZW91dFNldCA9IGZhbHNlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNvbWUgcmVxdWVzdHMgb3V0c3RhbmRpbmcsIGNoZWNrIGlmIGFueSBoYXZlIHRpbWVkLW91dFxuICBjb25zdCBub3cgPSB0aW1lc3RhbXAoKTtcbiAgY29uc3Qgc29vbmVzdFRpbWVvdXQgPSBzZXJ2ZXIucmVxdWVzdFRpbWVvdXRzWzBdO1xuXG4gIGlmIChzb29uZXN0VGltZW91dCA8PSBub3cpIHtcbiAgICAvLyB0aW1lb3V0IG9jY3VycmVkIVxuICAgIHNvY2suZW5kKCk7XG4gICAgc2VydmVyLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHNlcnZlci5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgIHNlcnZlci50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgc2VydmVyLmVycm9yKG5ldyBFcnJvcihcInNvY2tldCB0aW1lZCBvdXQgd2FpdGluZyBvbiByZXNwb25zZS5cIikpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vIHRpbWVvdXQhIFNldHVwIG5leHQgb25lLlxuICAgIGNvbnN0IGRlYWRsaW5lID0gc29vbmVzdFRpbWVvdXQgLSBub3c7XG4gICAgc29jay5zZXRUaW1lb3V0KGRlYWRsaW5lLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aW1lb3V0SGFuZGxlcihzZXJ2ZXIsIHNvY2spO1xuICAgIH0pO1xuICB9XG59O1xuIl19